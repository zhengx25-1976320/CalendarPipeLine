# -*- coding: utf-8 -*-
"""R2_StatementParser.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-JjMJAtdwu713186GxSHCUjvG5KIaALd

**Command Format:**

Schedule [action] [date/time] [person] [location]
Schedule a dinner at night with John at Marriot Hotel

## **Libraries**
"""

# !pip install datefinder

# !pip install parsedatetime

# !pip install Transformers

import datetime
import re
import nltk
nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')
import spacy
# nlp = spacy.load("en_core_web_sm")
import datefinder
from datetime import datetime, timedelta
import parsedatetime as pdt
import pandas as pd
# from google.colab import drive
from pandas.core.common import random_state
from transformers import BertTokenizer

# from google.colab import drive
# drive.mount('/content/drive')

"""## **Clean & Tokenization**"""

def extract_datetime(user_input):
    #start & end time and date
    cal = pdt.Calendar()
    now = datetime.now()
    eventTime = cal.parseDT(user_input, now)[0]

    if eventTime < now:
        return None

    date = eventTime.date()
    time = eventTime.time()
    date_time = datetime.combine(date,time)
    return date_time #date, time

#print("now: %s" % datetime.now())
#print(extract_datetime(''))
#extract_datetime('monday evening')

path = "/Users/anthonyxu/Documents/infoseeking/r2_statementparser.py"
def get_time_not_provided(event):
  #drive.mount('/gdrive') ## mounting google drive
  cal_corpus = pd.read_csv(path, sep = ',')
  for i in range(0,len(cal_corpus)):
    activity = cal_corpus['activity'][i]
    if activity.lower() in event.lower():
      start_time = cal_corpus['start'][i]
      duration = cal_corpus['duration'][i]
      end_time = cal_corpus[' end'][i]
      return duration #, start_time, end_time
  return None #, None, None

# print(get_time_not_provided("Add Dads Birthday party on Saturday"));

""" Old version
def get_nn(text):

    tokens = nltk.word_tokenize(text)
    pos = nltk.pos_tag(tokens)
    doc = nlp(text)
    pos = [(token, token.tag_) for token in doc]

    s = ''
    for p in pos:
        if s == '':
          if 'NN' in p[1]:
            s += str(p[0])
        else:
          if (p[1] == 'CN') or (p[1] == 'TM') or ('NN' in p[1]):
            s += ' '
            s += str(p[0])
          else:
            break
    return s.capitalize()
"""

#https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html
def get_nn(text):

    tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
    tokens = tokenizer.tokenize(text)
    pos = nltk.pos_tag(tokens)

    doc = nlp(text)
    tagged_words = [(token, token.tag_) for token in doc]

    noun_set = {'NN', 'NNS', 'NNP', 'NNPS'}
    verb_set = {'VB', 'VBd', 'VBG', 'VBN', 'VBP', 'VPZ'}
    avoid_set = {'schedule', 'add', 'minutes', 'minute', 'hour', 'hours'}

    s = '' #VB NN or NN NN

    length = len(tagged_words)
    i = 0
    while i < length-1:
        if str(tagged_words[i][0]).lower() in avoid_set:
            i +=1
            s = ""
            continue

        if tagged_words[i][1] in noun_set and tagged_words[i+1][1] in noun_set:
            s = str(tagged_words[i][0]) + " " + str(tagged_words[i+1][0])
            return s.capitalize()
        elif tagged_words[i][1] in verb_set and tagged_words[i+1][1] in noun_set:
            s = str(tagged_words[i][0]) + " " + str(tagged_words[i+1][0])
        elif i < length-2 and tagged_words[i][1] in noun_set and tagged_words[i+1][1] == 'IN' and tagged_words[i+2][1] in noun_set:
            s = str(tagged_words[i][0]) + " " + str(tagged_words[i+1][0]) + " " + str(tagged_words[i+2][0])
            return s.capitalize()
        i+=1
    if not s:
        text = text.lower()
        s = text.replace("schedule", "").lstrip()

    return s.capitalize()
# get_nn('Birthday party on Saturday')

def text_to_event(input_sentence):
  ###
  ### This function TAKES IN a natural langugag sentence in
  ### the type of string and RETURNS a dictionary of the features
  ### including names of people invited, date, time, and location.
  ###
  doc = nlp(input_sentence)

  # get subject of the event
  subject = get_nn(input_sentence)

  # get Names of people invited to the event
  people = [X.text for X in doc.ents if X.label_ in ['PERSON']]

  # get Date and Time
  matches = datefinder.find_dates(input_sentence)
  start_time = extract_datetime(input_sentence) #, time

  # get Location
  location = [X.text for X in doc.ents if X.label_ in ['ORG', 'LOC', 'GPE', 'FAC']]
  if len(location) > 0:
    location = location[0]
  else:
    location = ''

  # get Virtual event
  if 'zoom' in input_sentence:
    virtual = True
  else:
    virtual = False

  # get duration
  #duration = re.search(r'\d+\s(([a-z]+\s)+)?(hours|hour|minutes|minute)', input_sentence)
  #if duration != None:
    #duration = duration.group(0)

    hour = re.search(r'((\d+)?) hour', input_sentence)
    minute = re.search(r'((\d+)?) minute', input_sentence)
    end_time = None
    if hour != None:
        hour = int(hour.group(1))
        if minute != None:
          minute = int(minute.group(1))
          duration = timedelta(hours=hour, minutes=minute)
          end_time = start_time + duration
        else:
          duration = timedelta(hours=hour)
          end_time = start_time + duration
    else:
        if minute != None:
          minute = int(minute.group(1))
          duration = timedelta(minutes=minute)
          end_time = start_time + duration
        else:
          duration = None
          end_time = None
    if duration == None:
      seconds = get_time_not_provided(subject)
      if seconds != None:
        duration = timedelta(seconds=int(seconds))
      if start_time != None:
        end_time = start_time + duration


    # get recurring event
    day = re.search(r'every (\S+)', input_sentence)
    if day != None:
        day = day.group(1)

         #'time': time,

    features = {'event subject': subject, 'names': people, 'start date': start_time, 'duration': duration, 'end date' : end_time, 'location': location, 'virtual event': virtual, 'recurring day': day}

    return features

"""## **Test Cases**"""

#Testing the code
#subject,
inputs= ['Schedule my 2 hour 30 minutes piano lesson on Saturday 4:30 pm with julie at Morrison Hall.',
         'Schedule piano lesson for 2 hour 30 minutes on Saturday 4:30 pm with julie at Morrison Hall.',
         'lunch with John on saturday',
         'dinner with John on tuesday',
         'Find me 30 minutes to play Piano',
         'piano for 30 minutes',
         'Schedule lunch with Tina',
         'Schedule a car wash',
         'manicure',
         'Schedule a time to read New york times',
         'watch movie',
         'schedule a time to watch Louis c.k.',
         'schedule a run tomorrow',
         'schedule a doctors appointment',
         'schedule an appointment',
         'schedule a dinner with Jack',
         'Lunch with Anna at chipotle',
         'Lunch with Anna next Monday',
         'Schedule a meeting with Tina on Monday',
         'Add a shopping time with Anusha',
         'Add grocery shopping on Monday',
         'Add Dads Birthday party on Saturday'

]

# for input in inputs:
#     print(text_to_event(input))

"""## **Features Detection**

*   Title (Event)
*   Time (start, end, duration)
*   Attendee
*   Location
"""